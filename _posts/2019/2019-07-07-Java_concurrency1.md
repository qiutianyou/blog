---
layout: post
title: 并发-同步问题，加锁
category: Java
tags: [Java]
---

让我们聊聊并发。

* 多线程一定快吗？
这不一定，这是因为线程的创建和上下文的切换都需要时间开销

* 如何减少上下文的切换
  1. 无锁并发编程。在多线程竞争锁时，会引起上下文切换，所以在多线程处理数据时，可以用一些办法来避免使用锁。例如根据数据的id按照hash算法取模分段，不同的线程处理不同段的数据。
  2. cas算法，也就是自旋，如果发现其他线程已经获得锁，则立即通过自旋重新获取锁，而不是进入阻塞状态，重新调度。这里可以看出来，自旋的缺点：**自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销**
  3. 使用最少的线程。避免创建不需要的线程，任务量少的情况，创建了很多线程来处理，这样就会造成大量的线程处于等待状态
  4. 使用协程。在单线程里实现多任务的调度，并实现多任务间的切换。单线程自然也就减少了上下午切换了


## 锁的使用
多线程环境下，必须考虑线程同步的问题，这是因为多个线程同时访问变量或者资源时会有线程争用，比如A线程读取了一个变量，B线程也读取了这个变量，然后他们同时对这个变量做了修改，写回到内存中，由于是同时做修改，就会导致修改的状态不一致.

### synchronized
这个最熟悉不过的加锁方式了，但是在使用的时候我们必须知道synchronized不同的修饰对应锁的范围

```
1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。

2. 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。

3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。

```

synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。

线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。

### synchronized的优化
dk1.6以后对synchronized的锁进行了优化，引入了偏向锁、轻量级锁，锁的级别从低到高逐步升级：

无锁->偏向锁->轻量级锁->重量级锁

各种锁的优缺点

|锁|优点|缺点|适用场景|
|--|--|--|--|
|偏向锁|加锁和解锁不需要额外消耗|如果线程间出现锁竞争，会带来额外的锁撤销消耗|适用于一个线程访问同步快|
|轻量级锁|不会阻塞，提升响应速度|如果线程始终得不到锁，使用自旋会消耗cpu|追求响应速度，同步快执行速度非常快|
|重量级锁|线程竞争不使用自旋，不会消耗cpu|线程阻塞，需要重新调度，响应时间缓慢|追求吞吐量，同步代码块执行速度较长|

## ReenTrantLock

ReenTrantLock是Lock接口的实现,Lock 框架是同步的兼容替代品，它提供了 synchronized 没有提供的许多特性

1. synchronized是非公平锁，cpu随机调度。ReentrantLock可通过构造函数实例公平锁还是非公平锁

```
1. 公平锁：所有尝试获取锁的线程都会被插入阻塞队列尾部，在拥有锁的线程执行完毕之后按照先进先出的规则从队列中弹出线程执行锁定代码；

2. 非公平锁：初次调用lock.lock()方法的线程以及在阻塞队列头的线程都有权争夺锁的控制权，如果获取到了则执行后续代码，否则其会被加入到阻塞队列尾部。
```

2. ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们
3. ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。
4. ReenTrantLock提供了获取锁超时则返回的机制tryLock。


## 选择哪种加锁方式
建议用 synchronized 开发，直到确实证明 synchronized 不合适，而不要仅仅是假设如果使用 ReentrantLock “性能会更好”。

 在确实需要一些 synchronized 所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。 ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它
